from math import *
from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GLUT import *
from PIL import Image, ImageDraw

H = [] # массив высот

def loadLand(fileName): # функция загрузки картинки
    image = Image.open("map.jpg") # Открываем изображение
    global wH, hH # размеры ландшафта
    wH = image.size[0] # Определяем ширину
    hH = image.size[1] # Определяем высоту
    pix = image.load() # Выгружаем значения пикселей
    for x in range(wH):
        H.append([])
        for y in range(hH):
            H[x].append(pix[x, y]/10)

# Процедура инициализации
def init():
    glEnable(GL_DEPTH_TEST)
    glClearColor(0.0, 0.3, 0.0, 1.0)  # Белый цвет для первоначальной закраски
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(90, 600/600, 0.1, 100)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    #gluOrtho2D(-1.0, 1.0, -1.0, 1.0)  # Определяем границы рисования по горизонтали и вертикали
    global anglex, angley, anglez, filled
    anglex = 0
    angley = 0
    anglez = 0
    filled = 0

    loadLand("map.jpg")  # загружаем картинку в массив высот

# Процедура обработки обычных клавиш
def keyboardkeys(key, x, y):
    #print ('Pressed : ', key)
    global anglex, angley, anglez, filled
    if key == b'\x1b':
        sys.exit(0)
    if key == b'w':
        anglex += 5
    if key == b's':
        anglex -= 5
    if key == b'q':
        angley += 5
    if key == b'e':
        angley -= 5
    if key == b'a':
        anglez += 5
    if key == b'd':
        anglez -= 5
    if key == b' ':
        filled = 1 - filled
    glutPostRedisplay()  # Вызываем процедуру перерисовки


def Len(v):
    return sqrt(v[0]**2 + v[1]**2 + v[2]**2)

def Norm(v):
    if v[0] == 0 and v[1] == 0 and v[2] == 0:
        return v[0], v[1], v[2]
    else:
        return v[0] / Len(v), v[1] / Len(v), v[2] / Len(v)

def VxR(v, R):
    return v[0] * R, v[1] * R, v[2] * R

def VplusV(v, v1):
    return v[0] + v1[0], v[1] + v1[1], v[2] + v1[2]

def VminusV(v, v1):
    return v[0] - v1[0], v[1] - v1[1], v[2] - v1[2]

def VdotV(v, v1):
    return v[0] * v1[0] + v[1] * v1[1]+ v[2] * v1[2]

def VxV(v, v1):
    return (v[1] * v1[2] - v1[1] * v[2], \
            v[2] * v1[0] - v1[2] * v[0], \
            v[0] * v1[1] - v1[0] * v[1])

def mI():
    return (1,0,0),(0,1,0),(0,0,1)

def MxR(M, R):
    return VxR(M[0], R), VxR(M[1], R), VxR(M[2], R)

def MplusM(M1, M2):
    return VplusV(M1[0], M2[0]), VplusV(M1[1], M2[1]), VplusV(M1[2], M2[2])

def MminusM(M1, M2):
    return VminusV(M1[0], M2[0]), VminusV(M1[1], M2[1]), VminusV(M1[2], M2[2])

def MxV(M, v):
    return VdotV(M[0], v), VdotV(M[1], v), VdotV(M[2], v)

def MxM (m1,m2):
    v1 = (m2[0][0], m2[1][0], m2[2][0])
    v2 = (m2[0][1], m2[1][1], m2[2][1])
    v3 = (m2[0][2], m2[1][2], m2[2][2])
    return ((VdotV(m1[0], v1), VdotV(m1[0],v2), VdotV(m1[0],v3)),\
    (VdotV(m1[1], v1), VdotV(m1[1],v2), VdotV(m1[1],v3)),\
    (VdotV(m1[2], v1), VdotV(m1[2],v2), VdotV(m1[2],v3)))

def MRot(v, a):
    m1 = mI()
    s = ((0, v[2], -v[1]), (-v[2], 0, v[0]), (v[1], -v[0], 0))
    k = MplusM(m1, MxR(s, sin(a)))
    s2 = MxM(s, s)
    return (MplusM(k, MxR(s2, 1 - cos(a))))


def cylinder():
    R = 0.5

    glBegin(GL_TRIANGLE_FAN)

    glVertex3d(0, 0, -0.5)
    for i in range(21):
        glVertex3d(R * cos(2 * pi * i / 20), \
                   R * sin(2 * pi * i / 20), -0.5)

    glEnd()

    glBegin(GL_QUAD_STRIP)

    for i in range(21):
        glVertex3d(R * cos(2 * pi * i / 20), \
                   R * sin(2 * pi * i / 20), -0.5)
        glVertex3d(R * cos(2 * pi * i / 20), \
                   R * sin(2 * pi * i / 20), 0.5)

    glEnd()

    glBegin(GL_TRIANGLE_FAN)

    glVertex3d(0, 0, 0.5)
    for i in range(21):
        glVertex3d(R * cos(2 * pi * i / 20), \
                   R * sin(2 * pi * i / 20), 0.5)

    glEnd()

def conus():
    R = 0.5

    glBegin(GL_TRIANGLE_FAN)

    glVertex3d(0, 0, -0.5)
    for i in range(21):
        glVertex3d(R * cos(2 * pi * i / 20), \
                   R * sin(2 * pi * i / 20), -0.5)

    glEnd()

    glBegin(GL_TRIANGLE_FAN)

    glVertex3d(0, 0, 0.5)
    for i in range(21):
        glVertex3d(R * cos(2 * pi * i / 20), \
                   R * sin(2 * pi * i / 20), -0.5)

    glEnd()

def sphere():
    R = 0.5

    for j in range(-9, 9):
        glBegin(GL_QUAD_STRIP)

        for i in range(21):
            glVertex3d(R * cos(pi * j / 18) * cos(2 * pi * i / 20), \
                       R * cos(pi * j / 18) * sin(2 * pi * i / 20), \
                       R * sin(pi * j / 18))
            glVertex3d(R * cos(pi * (j + 1) / 18) * cos(2 * pi * i / 20), \
                       R * cos(pi * (j + 1) / 18) * sin(2 * pi * i / 20), \
                       R * sin(pi * (j + 1) / 18))

        glEnd()

def thor():
    R = 0.5
    R2 = R * 0.3

    for i in range(20):
        glBegin(GL_QUAD_STRIP)

        for j in range(21):
            glVertex3d((R + R2 * cos(2 * pi * j / 20)) * cos(2 * pi * i / 20), \
                       (R + R2 * cos(2 * pi * j / 20)) * sin(2 * pi * i / 20), \
                       R2 * sin(2 * pi * j / 20))
            glVertex3d((R + R2 * cos(2 * pi * j / 20)) * cos(2 * pi * (i + 1) / 20), \
                       (R + R2 * cos(2 * pi * j / 20)) * sin(2 * pi * (i + 1) / 20), \
                       R2 * sin(2 * pi * j / 20))

        glEnd()

def cube():
    glBegin(GL_QUADS)

    glVertex3d(0.5, 0.5, 0.5)
    glVertex3d(-0.5, 0.5, 0.5)
    glVertex3d(-0.5, -0.5, 0.5)
    glVertex3d(0.5, -0.5, 0.5)

    glVertex3d(0.5, 0.5, -0.5)
    glVertex3d(-0.5, 0.5, -0.5)
    glVertex3d(-0.5, -0.5, -0.5)
    glVertex3d(0.5, -0.5, -0.5)

    glVertex3d(0.5, 0.5, 0.5)
    glVertex3d(0.5, 0.5, -0.5)
    glVertex3d(0.5, -0.5, -0.5)
    glVertex3d(0.5, -0.5, 0.5)

    glVertex3d(-0.5, 0.5, 0.5)
    glVertex3d(-0.5, 0.5, -0.5)
    glVertex3d(-0.5, -0.5, -0.5)
    glVertex3d(-0.5, -0.5, 0.5)

    glVertex3d(0.5, 0.5, 0.5)
    glVertex3d(0.5, 0.5, -0.5)
    glVertex3d(-0.5, 0.5, -0.5)
    glVertex3d(-0.5, 0.5, 0.5)

    glVertex3d(0.5, -0.5, 0.5)
    glVertex3d(0.5, -0.5, -0.5)
    glVertex3d(-0.5, -0.5, -0.5)
    glVertex3d(-0.5, -0.5, 0.5)

    glEnd()

def gribok():
    glPushMatrix()
    glColor3f(1, 0, 0)
    glScaled(0.2, 0.2, 1)
    cylinder()
    glPopMatrix()

    glPushMatrix()
    glColor3f(0, 0, 1)
    glTranslated(0, 0, 0.5)
    glScaled(1, 1, 0.25)
    conus()
    glPopMatrix()

    glPushMatrix()
    glColor3f(0, 0.5, 0)
    glTranslated(0, 0, -0.5)
    glScaled(1, 1, 0.1)
    cylinder()
    glPopMatrix()

def domik():
    glPushMatrix()
    glScaled(1.5, 1.5, 0.5)
    cylinder()
    glPopMatrix()

    glPushMatrix()
    glTranslated(0, 0, 0.5)
    glScaled(1.5, 1.5, 0.5)
    conus()
    glPopMatrix()

# Процедура рисования
def draw(*args, **kwargs):
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)  # Очищаем экран и заливаем текущим цветом фона
    glLoadIdentity()
    global anglex, angley, anglez, filled
    glRotated(anglex, 1, 0, 0)
    glRotated(angley, 0, 1, 0)
    glRotated(anglez, 0, 0, 1)
    glRotated(-105, 1, 0, 0)
    if filled == 1:
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
    else:
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)

    for x in range(1, wH, 2):
        for y in range(1, hH, 2):
            glBegin(GL_TRIANGLE_FAN)
            glVertex3d(x, y, H[x][y])
            glVertex3d(x+1, y, H[x+1][y])
            glVertex3d(x+1, y+1, H[x+1][y+1])
            glVertex3d(x, y+1, H[x][y+1])
            glVertex3d(x-1, y+1, H[x-1][y+1])
            glVertex3d(x-1, y, H[x-1][y])
            glVertex3d(x-1, y-1, H[x-1][y-1])
            glVertex3d(x, y-1, H[x][y-1])
            glVertex3d(x+1, y-1, H[x+1][y-1])
            glVertex3d(x + 1, y, H[x + 1][y])
            glEnd()

    glutSwapBuffers()  # Меняем буферы
    glutPostRedisplay()  # Вызываем процедуру перерисовки


glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
glutInitWindowSize(600, 600)
glutInitWindowPosition(50, 50)
glutInit(sys.argv)
glutCreateWindow(b"OpenGL b\ Program!")
# Определяем процедуру, отвечающую за рисование
glutDisplayFunc(draw)
# Определяем процедуру, отвечающую за обработку обычных клавиш
glutKeyboardFunc(keyboardkeys)
# Вызываем нашу функцию инициализации
init()
glutMainLoop()

